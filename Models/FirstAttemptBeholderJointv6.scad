
// Let's go for some high-res spheres (I don't fully understand this variable!)
$fa = 6;

// Some parameters for the Beholder Joint
// These units are in mm
ball_radius = 100; // Ths inner ball of the Beholder
rotor_thickness = 10; // The thickness of the moving "rotors"
lock_thickness = 10; // The thickness of the locking shell
rotor_gap = 3; // a tolerance space to allow motion

// These units are in degrees
// some of these are explicitly created from my Gluss Pusher model
// 
least_spread_angle = 19.47;
most_spread_angle = 48.59;


// the edge difference of the rotor to make sure it doesn't fall out
safety_lip_angle = 4;

// the angle of the post (at the surface of the rotor!)
post_half_angle = 2;

// Computed parameters...
// Note taht I implicitly assuming this hole is centered on the 
// tetrahedronal geomety---that is neither necessary nor obviously
// correct in the case of Gluss Triangle.  I will have to 
// generate the holes by a more general mechanism later.
hole_angle = most_spread_angle - least_spread_angle;
radius_at_rotor_edge = ball_radius+rotor_thickness+2*rotor_gap;
hole_size_mm = radius_at_rotor_edge*2.0*sin(hole_angle/2);
echo("hole_size_mm = ");
echo(hole_size_mm);
rotor_size_mm = (ball_radius+rotor_thickness+2*rotor_gap)*2.0*sin((hole_angle+2*post_half_angle)/2.0);

post_radius_mm = radius_at_rotor_edge*sin(2*post_half_angle);

rotor_hole_angle = (most_spread_angle + least_spread_angle) / 2;


echo("Rotor Hole Angle");
echo(rotor_hole_angle);


// Tetrahedron

// base coordinates
// source:  http://dmccooey.com/polyhedra/Tetrahedron.txt
// generated by  http://kitwallace.co.uk/3d/solid-to-scad.xq
Name = "Tetrahedron";
// 3 sided faces = 4
C0 = 0.353553390593273762200422181052;
points = [
[ C0, -C0,  C0],
[ C0,  C0, -C0],
[-C0,  C0,  C0],
[-C0, -C0, -C0]];
faces = [
[ 2 , 1, 0],
[ 3 , 0, 1],
[ 0 , 3, 2],
[ 1 , 2, 3]];
edges = [
[1,2],
[0,1],
[0,2],
[0,3],
[1,3],
[2,3]];
// --------------------------------- 

// I don't understand all that Kit Wallace did below
// I am going to try to 

// cut holes out of shell
eps=0.02;
radius=20;
shell_ratio=0.1;
prism_base_ratio =0.8;
prism_height_ratio=0.3;
prism_scale=0.5;
nfaces = [];
scale=1;

//insert

// This code came from "Andrei" http://forum.openscad.org/Cylinders-td2443.html

module cylinder_ep(p1, p2, r1, r2) {
translate(p1)sphere(r=r1,center=true);
translate(p2)sphere(r=r2,center=true);
assign(vector = [p2[0] - p1[0],p2[1] - p1[1],p2[2] - p1[2]])
assign(distance = sqrt(pow(vector[0], 2) +
pow(vector[1], 2) +
pow(vector[2], 2)))
translate(vector/2 + p1)
//rotation of XoY plane by the Z axis with the angle of the [p1 p2] line projection with the X axis on the XoY plane
rotate([0, 0, atan2(vector[1], vector[0])]) //rotation
//rotation of ZoX plane by the y axis with the angle given by the z coordinate and the sqrt(x^2 + y^2)) point in the XoY plane
rotate([0, atan2(sqrt(pow(vector[0], 2)+pow(vector[1], 2)),vector[2]), 0])
cylinder(h = distance, r1 = r1, r2 = r2,center=true);
}

module box_ep(p1, p2, lintrans, w, d,h) {
// translate(p1)sphere(r=r1,center=true);
// translate(p2)sphere(r=r2,center=true);
assign(vector = [p2[0] - p1[0],p2[1] - p1[1],p2[2] - p1[2]])
assign(distance = sqrt(pow(vector[0], 2) +
pow(vector[1], 2) +
pow(vector[2], 2)))
translate(vector*lintrans + p1)
//rotation of XoY plane by the Z axis with the angle of the [p1 p2] line projection with the X axis on the XoY plane
rotate([0, 0, atan2(vector[1], vector[0])]) //rotation
//rotation of ZoX plane by the y axis with the angle given by the z coordinate and the sqrt(x^2 + y^2)) point in the XoY plane
rotate([0, atan2(sqrt(pow(vector[0], 2)+pow(vector[1], 2)),vector[2]), 0])
 difference() { // Cut six holes out!
cube([w,d,h],center=true);
translate([w/4,0,h/4]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);
translate([w/4,0,0]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);
translate([w/4,0,-h/4]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);
translate([-w/4,0,h/4]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);
translate([-w/4,0,0]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);
translate([-w/4,0,-h/4]) rotate([90,0,0]) cylinder(h=(w+h+d),r=(w/8),center=true);

 }
}
 

module cylindricalize_edges(edges,points,rad) {
    for(e = edges) {
        p0 = points[e[0]];
        p1 = points[e[1]];
        color("red") cylinder_ep(p0, p1, rad, rad, $fn=20);
    }
}

module beamify_edges(edges,points,width,depth,height) {
    for(e = edges) {
        p0 = points[e[0]];
        p1 = points[e[1]];
        color("green") box_ep(p0, p1, 0.37, width, depth, height, $fn=20);      
    }
}

// Create a tetrahedron-like strucutre with one point
// centered on the origin, symmetric about z axis,
// with an equilateral triangle as a base
// height - height of the pyrmid
// base - length of one side of the pyramid base
// r - raadius
module create_symmetric_3_member_polygon(height,base,r) {
    h = base*sqrt(3.0)/2.0;
    basehalf = base / 2.0;
    ZH = height;
points = [
    // first point is the origin
[ 0, 0, 0],
[ h*2/3,  0, -ZH],
[-h/3, -basehalf , -ZH],
[-h/3, basehalf, -ZH]];
edges = [
[0,1],
[0,2],
[0,3]
    ];
   cylindricalize_edges(edges,points,r); 
}

// Create a tetrahedron-like strucutre with one point
// centered on the origin, symmetric about z axis,
// with an equilateral triangle as a base
// height - height of the pyrmid
// base - length of one side of the pyramid base
// r - raadius
module create_symmetric_3_member_polygon_cube(height,base,r) {
    h = base*sqrt(3.0)/2.0;
    basehalf = base / 2.0;
    ZH = height;
points = [
    // first point is the origin
[ 0, 0, 0],
[ h*2/3,  0, -ZH],
[-h/3, -basehalf , -ZH],
[-h/3, basehalf, -ZH]];
edges = [
[0,1],
[0,2],
[0,3]
    ];
   beamify_edges(edges,points,hole_size_mm*0.8,post_radius_mm*2,100); 
}


module create_symmetric_3_member_polygon_polar(height,angle,r) {
    triangle_height = height*tan(angle)*3/2;
    base = triangle_height* 2 / sqrt(3.0);
    create_symmetric_3_member_polygon(height,base,r);
}

module create_symmetric_3_member_polygon_polar_cube(height,angle,r) {
    triangle_height = height*tan(angle)*3/2;
    base = triangle_height* 2 / sqrt(3.0);
    create_symmetric_3_member_polygon_cube(height,base,r);
}

module ball_locking_peg(width_factor = 10,height_factor = 3, tolerance_factor = 1.0) {
  translate([ball_radius/2,0,0]) cylinder(r = tolerance_factor * ball_radius/width_factor, h = tolerance_factor *ball_radius/height_factor,center = true);
}
module three_locking_pegs(tf) {  
 union() {
    rotate([0,0,0]) ball_locking_peg(tolerance_factor = tf);
    rotate([0,0,120]) ball_locking_peg(tolerance_factor = tf);
    rotate([0,0,240]) ball_locking_peg(tolerance_factor = tf);
 }
}

// I am really making this a hemisphere now
// so that we can see into it.  That of course 
// can be changed later.
module beholderBall(d) {
    difference() {
    union() {
        difference() {
            sphere(d);
            translate([-d,-d,0]) cube(2*d);
        }
        three_locking_pegs(0.95);
    }
    rotate([0,0,60]) three_locking_pegs(1.05);
}
}

module beholderLock(d) {
    inner = d + rotor_thickness + rotor_gap*2;
    outer = inner + lock_thickness;
    difference() {
        beholderBall(outer);
        sphere(inner);
    }
    
}

module beholderRotorsShell(d,buffer) {
    inner = d + rotor_gap;
    outer = inner + rotor_thickness;
    difference() {
        beholderBall(outer+buffer);
        sphere(inner-buffer);
    }
}

module equilateral_cut_tool_for_shell(rf) {
    difference() {
       create_symmetric_3_member_polygon_polar(ball_radius*4,rotor_hole_angle,rf);
       beholderBall(ball_radius);
    }
}

module planar_circle_cut_tool() {
              // rotate 30 degrees
            rotate([0,0,30])
            // Lay it onto x axix...
            rotate([0,90,0]) 
            cylinder(ball_radius*4,r=hole_size_mm/2);
}

module bolting_flange() { 
    translate([radius_at_rotor_edge+lock_thickness,0,-post_radius_mm])
    difference() {
    cylinder(r = hole_size_mm*0.4,h = post_radius_mm);
        translate([lock_thickness,0,-post_radius_mm])
         cylinder(r = hole_size_mm*0.1,h = post_radius_mm*4);
        translate([-ball_radius+-lock_thickness/2,-ball_radius/2,-ball_radius/2])
        cube(ball_radius);
    }
}

module bolting_flanges() {
    bolting_flange();
    rotate([0,0,120])
    bolting_flange();
    rotate([0,0,240])
    bolting_flange();
}

module snowflake_planar_cut_tool() {
    rotate([0,0,0]) planar_circle_cut_tool();
    rotate([0,0,60]) planar_circle_cut_tool();
    rotate([0,0,120]) planar_circle_cut_tool();
    rotate([0,0,180]) planar_circle_cut_tool();
    rotate([0,0,240]) planar_circle_cut_tool();
    rotate([0,0,300]) planar_circle_cut_tool();
}

module tetrahedronal_lock() {
    union() {
    difference() {
        beholderLock(ball_radius);
        equilateral_cut_tool_for_shell(hole_size_mm/2);
        // Now we will attempt to make the other cut outs...
        // These should split the angles of the tetrahedron...
        // So they should be rotate 30 degrees from the x-axis
       snowflake_planar_cut_tool();
    }
    color("green") bolting_flanges();
    }
}

module shell(id,od) {
    difference() {
        sphere(od);
        sphere(id);
    }
}

module tetrahedronal_pegs() {
    union() {
      difference() {
            difference() {
                create_symmetric_3_member_polygon_polar(ball_radius*4,rotor_hole_angle,post_radius_mm);
                sphere(ball_radius + rotor_gap + (rotor_thickness / 2.0));
            }
            shell(ball_radius*1.5,ball_radius*20);
    }
    color("green") create_symmetric_3_member_polygon_polar_cube(ball_radius*4,rotor_hole_angle,post_radius_mm);
   }
}

module tetrahedronal_rotors() {
// Now try to attach "pegs" to the rotor discs....
    union() {
       tetrahedronal_pegs();
    difference() { // clean up
        difference() {
            color("green") beholderRotorsShell(ball_radius,0);
            difference () {
                color("gray") beholderRotorsShell(ball_radius,0.5);
               equilateral_cut_tool_for_shell(rotor_size_mm/2.0);
            } 
        }
    // Needed to clean up artifacts...
        d = ball_radius;
       translate([-d*1.2,-d*1.2,-1]) cube(2.5*d);
    }
    }
}

module beholder_joint() {
   color( "Purple") beholderBall(ball_radius);
 //   tetrahedronal_rotors();
    tetrahedronal_lock();
}

beholder_joint();

color(black) three_locking_pegs();





